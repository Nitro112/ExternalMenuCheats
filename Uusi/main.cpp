// dear imgui - standalone example application for DirectX 11
// If you are new to dear imgui, see examples/README.txt and documentation at the top of imgui.cpp.
#include "Includes.h"
#include <sstream>
#include "imgui.h"
#include "imgui_impl_win32.h"
#include "imgui_impl_dx11.h"
#include <d3d11.h>
#define DIRECTINPUT_VERSION 0x0800
#include <dinput.h>
#include <tchar.h>
#include <stdio.h>
#include <string>
#include <iomanip>
#include "RCS.h"
#include <io.h>
#include <fcntl.h>
#include "JSON.h"
#pragma comment(lib, "urlmon.lib")
#include "lolz.hpp"

char BunnyINI[50];
char FireINI[50];
char WallINI[50];
char TriggerINI[50];
char FlashINI[50];
char RadarINI[50];

//Maaritellyt 

enum SigOnState
{
	STATE_NONE,
	CHALLENGE,
	CONNECTED,
	NEW,
	PRESPAWN,
	SPAWN,
	FULL_CONNECTED,
	CHANGELEVEL
};

using namespace std;
#pragma comment(lib, "dwmapi.lib")
#include "Dwmapi.h"
#pragma warning (disable: 4305)
#pragma warning (disable: 4390)
#pragma warning (disable: 4005)
#pragma warning (disable: 4244)
#pragma warning (disable: 4189)
#pragma warning (disable: 4100)
#pragma warning (disable: 4127)
void dankmemeforthewin()
{
	float pJunkcode = 53219789111453;
	pJunkcode = 134117655665242;
	if (pJunkcode = 16236541132425)
		pJunkcode = 183974691741225;
	pJunkcode = 32165411111425;
	pJunkcode = 111178978911;
	if (pJunkcode = 34925792490534);
	pJunkcode = 23048921633748943;
	pJunkcode = 439090453;
	if (pJunkcode = 17138592425)
		pJunkcode = 1838912425;
	pJunkcode = 17001283641;
	pJunkcode = 1231667753534;
	if (pJunkcode = 34923423422342342);
	pJunkcode = 2304813748943;
	pJunkcode = 4390751390453;
	if (pJunkcode = 17343425)
		pJunkcode = 422342543425;
	pJunkcode = 1343443965;
	pJunkcode = 4353284383434;
	if (pJunkcode = 33461154517349054);
	pJunkcode = 26114656567148946;
	pJunkcode = 439111114912;
	if (pJunkcode = 17138592425)
		pJunkcode = 1838912425;
	pJunkcode = 17332118925;
	pJunkcode = 4357811266534;
	if (pJunkcode = 34923473490534);
	pJunkcode = 2304813748943;
	pJunkcode = 4390751390453;
	if (pJunkcode = 1739342425)
		pJunkcode = 18345132543425;
	pJunkcode = 171112313231248965;
	pJunkcode = 4387764556616534;
	pJunkcode = 100123142319848965;
	pJunkcode = 433321113416534;
	pJunkcode = 1738674329848965;
	pJunkcode = 435329513416534;
	if (pJunkcode = 33871236541842354);
	pJunkcode = 26112365478948946;
	pJunkcode = 438875422112;
	pJunkcode = 173242319848965;
	pJunkcode = 43532332323416534;
	pJunkcode = 17324123131848965;
	pJunkcode = 4353291928834;
}

#include <stdio.h>
#include <string>
#include <iostream>

using namespace std;

class wymxcev {
public:
	string mwjzuplsbcpd;
	int zjdruaicp;
	bool dbzcujaxqmf;
	wymxcev();
	void timqudekanmjejoxsrk(bool jtdjtg, bool rzxdh, int hinfam, double kfchwrkaqcxh, bool etakumaatasajw, string ldlbxrc, double lvyxuqxo);
	int spntqtxyudwvmu(bool ofhtyxgndymhlsl, string ieurpiqsoncjzu, string qinnawbb);

protected:
	int ucals;
	int cxfvsaxgf;

	string ilklervlzopdodlu(bool fspghijnxng, int ocqgdzlht, string nhedqtcsbtp, string hexwbxcnbv);
	bool wdixxvntogbhhoje(bool mpnqq, double twvkhy, string kdmhjdexnksgqjz, double ltpgc, string ajndiskpwubnf);
	void chwjvgrsjeovjtbyw(int dgceeybikye, int tnkfglwdhuk, double xxkrvdt);
	double azxmavfykonbavnhkxgfsx(int bnzfbxo, bool zuvuwljkgongtaz, int okeuwqk, bool mivorbrbfh, int onzgmqkjfrmsw, string prngzqxbilh, string lequpzwapdn);
	string uwisfxxaaocueufdwwjw(double ggnye, int evdvls);
	double eedvmvrknnutdwwe(double iaimfhcbkn, bool eczczjie, string bqzxrdnipq, int bcrnxlz, double bhspht, int hievvysp);
	string lfuecjskkqjmlclewznikcaj(int prmwa, string docyvseq, int lqfrtocz, double igkvuh, double glrxz, bool asxczixxdwn, bool yxkeodxyi, int ozvlgpjzmqvimdg, double oqmcbnweyfkbvj);
	bool pxpcpbyeablzgrat(int ymacnkebhrxxaij, double blqlcqnkxxl, int nwgilvmulv, int nkgeekvgk, string gmorwioiv);
	int prrpmiwctpevmpehsnjtsyxew(double xgsfggscuawd);

private:
	int gnbydhcnmixccy;
	double doexusxpexzckat;
	bool vcybsovdrrczjv;
	int afiavc;

	void cptiyqqdeaqdhps(string yozdwhoj, bool dbejouokct, int wmgpzg, bool kmifrzguedh, double qxfsdyy, string xpwpvhkhsgkifli, int sfzrhtxieq, double jqmevfljvbb);

};


void wymxcev::cptiyqqdeaqdhps(string yozdwhoj, bool dbejouokct, int wmgpzg, bool kmifrzguedh, double qxfsdyy, string xpwpvhkhsgkifli, int sfzrhtxieq, double jqmevfljvbb) {
	string qbcbhgfhfvlhzx = "jaownujewatwzwchoftgvhjzzqoxoyeivt";
	bool rgslghuu = false;
	bool wqpmp = false;
	if (false != false) {
		int vvogxowj;
		for (vvogxowj = 89; vvogxowj > 0; vvogxowj--) {
			continue;
		}
	}
	if (false != false) {
		int nqr;
		for (nqr = 16; nqr > 0; nqr--) {
			continue;
		}
	}
	if (false != false) {
		int uz;
		for (uz = 96; uz > 0; uz--) {
			continue;
		}
	}
	if (false != false) {
		int rbfypu;
		for (rbfypu = 8; rbfypu > 0; rbfypu--) {
			continue;
		}
	}
	if (false == false) {
		int dhxm;
		for (dhxm = 52; dhxm > 0; dhxm--) {
			continue;
		}
	}

}

string wymxcev::ilklervlzopdodlu(bool fspghijnxng, int ocqgdzlht, string nhedqtcsbtp, string hexwbxcnbv) {
	return string("dlfkbimxryadqdrwju");
}

bool wymxcev::wdixxvntogbhhoje(bool mpnqq, double twvkhy, string kdmhjdexnksgqjz, double ltpgc, string ajndiskpwubnf) {
	string ocntucgzhzgu = "haomllozajudfzwlknlkhwdfopztyrahszwirl";
	string imwfiypnnnfeq = "kfrbxqlebxjdsijwfasjzkmmbksvcyxr";
	string qmhlecdbnqbwu = "cbzzxwozfhqowmdiqdvscwkrgdfdeabersroujridkvgicvfvmqvmvvujlxantfpszatozmtmvbszjwtynh";
	double ulbxvkdxjtgw = 5511;
	string bxdekgtrhhfthk = "jnimmpublpfkpvwvzkhmlbtskswuekpnfnecsprjjiwzse";
	double gybfzoenp = 38528;
	double xxodgpdvjmhqssq = 11010;
	if (string("kfrbxqlebxjdsijwfasjzkmmbksvcyxr") != string("kfrbxqlebxjdsijwfasjzkmmbksvcyxr")) {
		int yctryyze;
		for (yctryyze = 89; yctryyze > 0; yctryyze--) {
			continue;
		}
	}
	return true;
}

void wymxcev::chwjvgrsjeovjtbyw(int dgceeybikye, int tnkfglwdhuk, double xxkrvdt) {

}

double wymxcev::azxmavfykonbavnhkxgfsx(int bnzfbxo, bool zuvuwljkgongtaz, int okeuwqk, bool mivorbrbfh, int onzgmqkjfrmsw, string prngzqxbilh, string lequpzwapdn) {
	string ihqwczjflyec = "nydoskapfyqwbznexiojw";
	bool hctreu = false;
	string vbexosq = "tdjeyhhtwxqjlddgbmugnulkjiuurjqlggfxdbsnhyawgbrxuwjgqljyqalhukrgaypteklhpvpiwtemmlupgxsahpwrietbljrn";
	int acsdbtbmnkroi = 847;
	bool bofbimgqejq = false;
	bool xvlgccuci = true;
	int oeizmrp = 810;
	int bzkigbulcjs = 2244;
	int ritsjmrulojdsdh = 1259;
	double qrlzxleq = 63348;
	if (true == true) {
		int wmn;
		for (wmn = 42; wmn > 0; wmn--) {
			continue;
		}
	}
	if (string("tdjeyhhtwxqjlddgbmugnulkjiuurjqlggfxdbsnhyawgbrxuwjgqljyqalhukrgaypteklhpvpiwtemmlupgxsahpwrietbljrn") == string("tdjeyhhtwxqjlddgbmugnulkjiuurjqlggfxdbsnhyawgbrxuwjgqljyqalhukrgaypteklhpvpiwtemmlupgxsahpwrietbljrn")) {
		int yxsdbsbqoj;
		for (yxsdbsbqoj = 20; yxsdbsbqoj > 0; yxsdbsbqoj--) {
			continue;
		}
	}
	if (63348 != 63348) {
		int xjkbchlddv;
		for (xjkbchlddv = 36; xjkbchlddv > 0; xjkbchlddv--) {
			continue;
		}
	}
	if (2244 == 2244) {
		int cgkpiu;
		for (cgkpiu = 41; cgkpiu > 0; cgkpiu--) {
			continue;
		}
	}
	return 10941;
}

string wymxcev::uwisfxxaaocueufdwwjw(double ggnye, int evdvls) {
	double tiumstwuhmcbk = 16028;
	int gusjfpo = 2695;
	double yvcnlwivsav = 19883;
	bool jzjtyufer = false;
	string rpgtsn = "gxijled";
	bool lepdqtln = true;
	double mqqknoer = 21606;
	string xwxignyavdqtzhz = "lcdtljsagblbphyklaypdzygxvukwhvwomgwzjlwfbhnrhioqoxkaskfrduoanemnvmeqrhbxnfayweeibuiwx";
	int djedhxxwgfj = 356;
	if (string("gxijled") != string("gxijled")) {
		int qogoj;
		for (qogoj = 70; qogoj > 0; qogoj--) {
			continue;
		}
	}
	if (16028 == 16028) {
		int au;
		for (au = 96; au > 0; au--) {
			continue;
		}
	}
	if (string("lcdtljsagblbphyklaypdzygxvukwhvwomgwzjlwfbhnrhioqoxkaskfrduoanemnvmeqrhbxnfayweeibuiwx") != string("lcdtljsagblbphyklaypdzygxvukwhvwomgwzjlwfbhnrhioqoxkaskfrduoanemnvmeqrhbxnfayweeibuiwx")) {
		int coauhzvwsh;
		for (coauhzvwsh = 71; coauhzvwsh > 0; coauhzvwsh--) {
			continue;
		}
	}
	if (true != true) {
		int vfda;
		for (vfda = 21; vfda > 0; vfda--) {
			continue;
		}
	}
	return string("kuzwfzmdprbbf");
}

double wymxcev::eedvmvrknnutdwwe(double iaimfhcbkn, bool eczczjie, string bqzxrdnipq, int bcrnxlz, double bhspht, int hievvysp) {
	return 81428;
}

string wymxcev::lfuecjskkqjmlclewznikcaj(int prmwa, string docyvseq, int lqfrtocz, double igkvuh, double glrxz, bool asxczixxdwn, bool yxkeodxyi, int ozvlgpjzmqvimdg, double oqmcbnweyfkbvj) {
	bool nabssxbkb = false;
	string kjimjgzxt = "syqhwxwhnrxyxrphxdvogsdhmkoorrezsyyhbxftcwhagtmkzlruslppnalsk";
	double jshorbywosumdh = 10850;
	bool kocjerunewafhy = true;
	int mnpkbegmyyl = 3493;
	string eektdrihkg = "dotxmmblsdqmquugsnhflvwjfcqnnphdhebrovxelvprdlkkukjlxlzgorlexa";
	double pifojryfpfegxgp = 24316;
	string crqaedtzc = "fpfwoqnuhdcrxjyczpgdvyzbmbedg";
	if (10850 == 10850) {
		int vh;
		for (vh = 86; vh > 0; vh--) {
			continue;
		}
	}
	if (3493 != 3493) {
		int zqh;
		for (zqh = 26; zqh > 0; zqh--) {
			continue;
		}
	}
	if (string("syqhwxwhnrxyxrphxdvogsdhmkoorrezsyyhbxftcwhagtmkzlruslppnalsk") == string("syqhwxwhnrxyxrphxdvogsdhmkoorrezsyyhbxftcwhagtmkzlruslppnalsk")) {
		int qngjvzkizd;
		for (qngjvzkizd = 40; qngjvzkizd > 0; qngjvzkizd--) {
			continue;
		}
	}
	if (string("fpfwoqnuhdcrxjyczpgdvyzbmbedg") == string("fpfwoqnuhdcrxjyczpgdvyzbmbedg")) {
		int aehyix;
		for (aehyix = 61; aehyix > 0; aehyix--) {
			continue;
		}
	}
	return string("atni");
}

bool wymxcev::pxpcpbyeablzgrat(int ymacnkebhrxxaij, double blqlcqnkxxl, int nwgilvmulv, int nkgeekvgk, string gmorwioiv) {
	return true;
}

int wymxcev::prrpmiwctpevmpehsnjtsyxew(double xgsfggscuawd) {
	int vgxtrjgnddox = 5928;
	int nwzsxzdngyo = 1922;
	double gfcaldqspvloksm = 41914;
	int bjymobiukthpj = 799;
	int ztsgzqyw = 1170;
	if (5928 == 5928) {
		int xnnq;
		for (xnnq = 62; xnnq > 0; xnnq--) {
			continue;
		}
	}
	if (1922 == 1922) {
		int dt;
		for (dt = 90; dt > 0; dt--) {
			continue;
		}
	}
	if (799 == 799) {
		int mgiuvgm;
		for (mgiuvgm = 71; mgiuvgm > 0; mgiuvgm--) {
			continue;
		}
	}
	if (1170 != 1170) {
		int wnrl;
		for (wnrl = 28; wnrl > 0; wnrl--) {
			continue;
		}
	}
	return 98699;
}

void wymxcev::timqudekanmjejoxsrk(bool jtdjtg, bool rzxdh, int hinfam, double kfchwrkaqcxh, bool etakumaatasajw, string ldlbxrc, double lvyxuqxo) {
	double odotsvxqkbcyhjk = 7764;
	double dvtmkeqyjwgqgmp = 13190;
	int qmouryd = 124;
	int abzdqvul = 116;
	int mbsjydpeutblp = 4414;
	bool sjsxsnszo = true;
	int gkxiweimpgr = 1257;
	int lguhipesjglzzg = 1058;
	string coctds = "llgbesgrzbvelhqbhmwyfwmayikrunfcblnqkzdrakzrgesamzwxxyfaxuqxzmwjcbvhikgqwgmcamekzbguytzrxtmmruff";
	string enmti = "ywuzufo";
	if (1257 == 1257) {
		int ku;
		for (ku = 32; ku > 0; ku--) {
			continue;
		}
	}
	if (13190 == 13190) {
		int agcemqsoc;
		for (agcemqsoc = 27; agcemqsoc > 0; agcemqsoc--) {
			continue;
		}
	}

}

int wymxcev::spntqtxyudwvmu(bool ofhtyxgndymhlsl, string ieurpiqsoncjzu, string qinnawbb) {
	int hfqyvetmq = 2933;
	bool sshpisrxaxbamp = true;
	double gjvovlkshi = 13317;
	bool vxdxb = true;
	if (true == true) {
		int zbwxeli;
		for (zbwxeli = 29; zbwxeli > 0; zbwxeli--) {
			continue;
		}
	}
	if (true != true) {
		int fxumdcyuk;
		for (fxumdcyuk = 83; fxumdcyuk > 0; fxumdcyuk--) {
			continue;
		}
	}
	return 27944;
}

wymxcev::wymxcev() {
	this->timqudekanmjejoxsrk(false, true, 3600, 60122, false, string("kqbd"), 7695);
	this->spntqtxyudwvmu(false, string("hvduogtkxfeegijsdegcaoduvhjulfnvlewjzyhxszkbdovaleqogyqrcndfnlyelomhnlifwofiojpguzjgsoibovauymsejbf"), string("zdbpgnubyyodvswwbwzictnzvvnxxxbgtruyyqxrvmojzbyqdjxhpwwdndamujtpmtnzmcnpwyaqctnpvpau"));
	this->ilklervlzopdodlu(true, 1944, string("ofmtswxmyzarxqprmsyfucwztyfkyfobmqjddwioeoujoxxfgrutltmlcjrjoszdmlcydxczepkkwmluhu"), string("dptkpf"));
	this->wdixxvntogbhhoje(true, 32061, string("snib"), 16073, string("asuydjwxvwafzpajeazpoaexnplwztzuligxycehlgoyvrnklvifoaewbjkqjbpsbisrwq"));
	this->chwjvgrsjeovjtbyw(243, 1955, 76592);
	this->azxmavfykonbavnhkxgfsx(7254, false, 276, true, 3366, string("ojhnlnfiellxnxyeksbsak"), string("bjnoytmazgxbctakmwqvvzifonlcojbxxyidqnanbfyazvegusbsbeuzlzbbhuqtzrhiexjcywfoz"));
	this->uwisfxxaaocueufdwwjw(25451, 349);
	this->eedvmvrknnutdwwe(1681, true, string("sshivwy"), 469, 62965, 1017);
	this->lfuecjskkqjmlclewznikcaj(2728, string("fw"), 6005, 37832, 46762, false, true, 3299, 805);
	this->pxpcpbyeablzgrat(7414, 1360, 100, 3379, string("fadxdzodtxenkeczywfhpfcyk"));
	this->prrpmiwctpevmpehsnjtsyxew(1346);
	this->cptiyqqdeaqdhps(string("jwgnjovmrahsxqffncghvkjv"), true, 888, true, 28234, string("dpdxspfzgnkgrijsbhkmjaxac"), 2306, 1191);
}



// Data
static ID3D11Device*            g_pd3dDevice = NULL;
static ID3D11DeviceContext*     g_pd3dDeviceContext = NULL;
static IDXGISwapChain*          g_pSwapChain = NULL;
static ID3D11RenderTargetView*  g_mainRenderTargetView = NULL;

using namespace std;
typedef unsigned char uint8_t;

template <typename T, size_t N>

size_t countof(T(&array)[N])
{
	return N;
}


void CreateRenderTarget()
{
    ID3D11Texture2D* pBackBuffer;
    g_pSwapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), (LPVOID*)&pBackBuffer);
    g_pd3dDevice->CreateRenderTargetView(pBackBuffer, NULL, &g_mainRenderTargetView);
    pBackBuffer->Release();
}

void CleanupRenderTarget()
{
    if (g_mainRenderTargetView) { g_mainRenderTargetView->Release(); g_mainRenderTargetView = NULL; }
}

HRESULT CreateDeviceD3D(HWND hWnd)
{
    // Setup swap chain
    DXGI_SWAP_CHAIN_DESC sd;
    ZeroMemory(&sd, sizeof(sd));
    sd.BufferCount = 2;
    sd.BufferDesc.Width = 0;
    sd.BufferDesc.Height = 0;
    sd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
    sd.BufferDesc.RefreshRate.Numerator = 60;
    sd.BufferDesc.RefreshRate.Denominator = 1;
    sd.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;
    sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
    sd.OutputWindow = hWnd;
    sd.SampleDesc.Count = 1;
    sd.SampleDesc.Quality = 0;
    sd.Windowed = TRUE;
    sd.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;

    UINT createDeviceFlags = 0;
    //createDeviceFlags |= D3D11_CREATE_DEVICE_DEBUG;
    D3D_FEATURE_LEVEL featureLevel;
    const D3D_FEATURE_LEVEL featureLevelArray[2] = { D3D_FEATURE_LEVEL_11_0, D3D_FEATURE_LEVEL_10_0, };
    if (D3D11CreateDeviceAndSwapChain(NULL, D3D_DRIVER_TYPE_HARDWARE, NULL, createDeviceFlags, featureLevelArray, 2, D3D11_SDK_VERSION, &sd, &g_pSwapChain, &g_pd3dDevice, &featureLevel, &g_pd3dDeviceContext) != S_OK)
        return E_FAIL;

    CreateRenderTarget();

    return S_OK;
}

void CleanupDeviceD3D()
{
    CleanupRenderTarget();
    if (g_pSwapChain) { g_pSwapChain->Release(); g_pSwapChain = NULL; }
    if (g_pd3dDeviceContext) { g_pd3dDeviceContext->Release(); g_pd3dDeviceContext = NULL; }
    if (g_pd3dDevice) { g_pd3dDevice->Release(); g_pd3dDevice = NULL; }
}

extern LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT WINAPI WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    if (ImGui_ImplWin32_WndProcHandler(hWnd, msg, wParam, lParam))
        return true;

    switch (msg)
    {
    case WM_SIZE:
        if (g_pd3dDevice != NULL && wParam != SIZE_MINIMIZED)
        {
            CleanupRenderTarget();
            g_pSwapChain->ResizeBuffers(0, (UINT)LOWORD(lParam), (UINT)HIWORD(lParam), DXGI_FORMAT_UNKNOWN, 0);
            CreateRenderTarget();
        }
        return 0;
    case WM_SYSCOMMAND:
        if ((wParam & 0xfff0) == SC_KEYMENU) // Disable ALT application menu
            return 0;
        break;
    case WM_DESTROY:
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProc(hWnd, msg, wParam, lParam);
}

void ChangeClickability(bool canclick, HWND ownd)
{
	wymxcev::wymxcev();
	long style = GetWindowLong(ownd, GWL_EXSTYLE);
	if (canclick) {
		style &= ~WS_EX_LAYERED;
		SetWindowLong(ownd, GWL_EXSTYLE, style);
		SetForegroundWindow(ownd);
		//windowstate = 1;
	}
	else {
		style |= WS_EX_LAYERED;
		SetWindowLong(ownd, GWL_EXSTYLE, style);
		//windowstate = 0;
	}
}


void normalizeAngles(D3DXVECTOR3& angles)
{
	while (angles.y > 180.f) {
		angles.y -= 360.f;
	}

	while (angles.y < -180.f){
		angles.y += 360.f;
	}
}

void clampAngles(D3DXVECTOR3& angles)
{
	if (angles.x > 89.0) {
		angles.x = 89.0;
	}
	if (angles.x < -89.0) {
		angles.x = -89.0;
	}
	if (angles.y > 180.0) {
		angles.y = 180.0;
	}
	if (angles.y < -180.0) {
		angles.y = -180.0;
	}
}

D3DXVECTOR3 getAnglesTo(DWORD playerToAim)
{
	auto base = playerToAim;
	if (Entity::getEntTeam(base) != LocalPlayer::getLocalTeam() && Entity::isValid(base))
	{
		D3DXVECTOR3 LocalPos = LocalPlayer::getAbsolutePos();
		D3DXVECTOR3 punchAngles = LocalPlayer::getLocalPunchAngles();
		D3DXVECTOR3 dPosition = LocalPos - Entity::getEntBonePos(base, 8);

		float dist = sqrt(pow(dPosition.x, 2) + pow(dPosition.y, 2));

		float angleXToPlayer = (atan(dPosition.x / dPosition.y)) * (180.0 / 3.14159265359);
		float angleYToPlayer = (atan2f(dPosition.z , dist)) * (180.0 / 3.14159265359);

		D3DXVECTOR3 newAngle((float)(angleYToPlayer), (float)(angleXToPlayer - 90.f), (0));

		if (dPosition.y >= 0) {
			newAngle.y += 180.f;
		}

		newAngle.y = newAngle.y*-1.f;

		normalizeAngles(newAngle);
		clampAngles(newAngle);

		return newAngle;
	}
}

int SigOnState()
{
	return rpm<int>(clientState + g_offsets::dwClientState_State);
}

bool Parser(char Parse[]){
	if (!strcmp(Parse, "true")) {
		return true;
	}
	else
		return false;
}

void update()
{
	HRESULT hr = URLDownloadToFile(NULL, _T("https://raw.githubusercontent.com/frk1/hazedumper/master/csgo.json"), _T("netvars.json"), 0, NULL);
	if (hr != S_OK) {
		MessageBoxA(NULL, "Error occoured on connection to github!", "Error", 0);
		exit(0);
	}
	FILE* infile = fopen("netvars.json", "r");
	fseek(infile, 0, SEEK_END);
	long filesize = ftell(infile);
	char* buf = new char[filesize + 1];
	fseek(infile, 0, SEEK_SET);
	fread(buf, 1, filesize, infile);
	fclose(infile);
	buf[filesize] = '\0';
	std::stringstream ss;
	ss.str(buf);
	delete[] buf;
	Json::Value netvars;
	ss >> netvars;
	g_offsets::dwLocalPlayer = netvars["signatures"]["dwLocalPlayer"].asInt();
	g_offsets::clientstate_choked_commands = netvars["signatures"]["clientstate_choked_commands"].asInt();
	g_offsets::dwForceAttack = netvars["signatures"]["dwForceAttack"].asInt();
	g_offsets::m_bDormant = netvars["signatures"]["m_bDormant"].asInt();
	g_offsets::dwForceJump = netvars["signatures"]["dwForceJump"].asInt();
	g_offsets::dwGlowObjectManager = netvars["signatures"]["dwGlowObjectManager"].asInt();
	g_offsets::clientstate_delta_ticks = netvars["signatures"]["clientstate_delta_ticks"].asInt();
	g_offsets::clientstate_last_outgoing_command = netvars["signatures"]["clientstate_last_outgoing_command"].asInt();
	g_offsets::clientstate_net_channel = netvars["signatures"]["clientstate_net_channel"].asInt();
	g_offsets::convar_name_hash_table = netvars["signatures"]["convar_name_hash_table"].asInt();
	g_offsets::dwClientState = netvars["signatures"]["dwClientState"].asInt();
	g_offsets::dwClientState_GetLocalPlayer = netvars["signatures"]["dwClientState_GetLocalPlayer"].asInt();
	g_offsets::dwClientState_IsHLTV = netvars["signatures"]["dwClientState_IsHLTV"].asInt();
	g_offsets::dwClientState_Map = netvars["signatures"]["dwClientState_Map"].asInt();
	g_offsets::dwClientState_MapDirectory = netvars["signatures"]["dwClientState_MapDirectory"].asInt();
	g_offsets::dwClientState_MaxPlayer = netvars["signatures"]["dwClientState_MaxPlayer"].asInt();
	g_offsets::dwClientState_PlayerInfo = netvars["signatures"]["dwClientState_PlayerInfo"].asInt();
	g_offsets::dwClientState_State = netvars["signatures"]["dwClientState_State"].asInt();
	g_offsets::dwClientState_ViewAngles = netvars["signatures"]["dwClientState_ViewAngles"].asInt();
	g_offsets::dwEntityList = netvars["signatures"]["dwEntityList"].asInt();
	g_offsets::dwForceAttack = netvars["signatures"]["dwForceAttack"].asInt();
	g_offsets::dwForceAttack2 = netvars["signatures"]["dwForceAttack2"].asInt();
	g_offsets::dwForceBackward = netvars["signatures"]["dwForceBackward"].asInt();
	g_offsets::dwForceForward = netvars["signatures"]["dwForceForward"].asInt();
	g_offsets::dwForceJump = netvars["signatures"]["dwForceJump"].asInt();
	g_offsets::dwForceLeft = netvars["signatures"]["dwForceLeft"].asInt();
	g_offsets::dwForceRight = netvars["signatures"]["dwForceRight"].asInt();
	g_offsets::dwGameDir = netvars["signatures"]["dwGameDir"].asInt();
	g_offsets::dwGameRulesProxy = netvars["signatures"]["dwGameRulesProxy"].asInt();
	g_offsets::dwGetAllClasses = netvars["signatures"]["dwGetAllClasses"].asInt();
	g_offsets::dwGlobalVars = netvars["signatures"]["dwGlobalVars"].asInt();
	g_offsets::dwGlowObjectManager = netvars["signatures"]["dwGlowObjectManager"].asInt();
	g_offsets::dwInput = netvars["signatures"]["dwInput"].asInt();
	g_offsets::dwInterfaceLinkList = netvars["signatures"]["dwInterfaceLinkList"].asInt();
	g_offsets::dwMouseEnable = netvars["signatures"]["dwMouseEnable"].asInt();
	g_offsets::dwMouseEnablePtr = netvars["signatures"]["dwMouseEnablePtr"].asInt();
	g_offsets::dwPlayerResource = netvars["signatures"]["dwPlayerResource"].asInt();
	g_offsets::dwRadarBase = netvars["signatures"]["dwRadarBase"].asInt();
	g_offsets::dwSensitivity = netvars["signatures"]["dwSensitivity"].asInt();
	g_offsets::dwSensitivityPtr = netvars["signatures"]["dwSensitivityPtr"].asInt();
	g_offsets::dwSetClanTag = netvars["signatures"]["dwSetClanTag"].asInt();
	g_offsets::dwViewMatrix = netvars["signatures"]["dwViewMatrix"].asInt();
	g_offsets::dwWeaponTable = netvars["signatures"]["dwWeaponTable"].asInt();
	g_offsets::dwWeaponTableIndex = netvars["signatures"]["dwWeaponTableIndex"].asInt();
	g_offsets::dwYawPtr = netvars["signatures"]["dwYawPtr"].asInt();
	g_offsets::dwZoomSensitivityRatioPtr = netvars["signatures"]["dwZoomSensitivityRatioPtr"].asInt();
	g_offsets::dwbSendPackets = netvars["signatures"]["dwbSendPackets"].asInt();
	g_offsets::dwppDirect3DDevice9 = netvars["signatures"]["dwppDirect3DDevice9"].asInt();
	g_offsets::interface_engine_cvar = netvars["signatures"]["interface_engine_cvar"].asInt();
	g_offsets::m_pStudioHdr = netvars["signatures"]["m_pStudioHdr"].asInt();
	g_offsets::m_bDormant = netvars["signatures"]["m_bDormant"].asInt();
	g_offsets::m_pitchClassPtr = netvars["signatures"]["m_pitchClassPtr"].asInt();
	g_offsets::m_yawClassPtr = netvars["signatures"]["m_yawClassPtr"].asInt();
	g_offsets::model_ambient_min = netvars["signatures"]["model_ambient_min"].asInt();

	g_netvars::cs_gamerules_data = netvars["netvars"]["cs_gamerules_data"].asInt();
	g_netvars::m_ArmorValue = netvars["netvars"]["m_ArmorValue"].asInt();
	g_netvars::m_Collision = netvars["netvars"]["m_Collision"].asInt();
	g_netvars::m_CollisionGroup = netvars["netvars"]["m_CollisionGroup"].asInt();
	g_netvars::m_Local = netvars["netvars"]["m_Local"].asInt();
	g_netvars::m_MoveType = netvars["netvars"]["m_MoveType"].asInt();
	g_netvars::m_OriginalOwnerXuidHigh = netvars["netvars"]["m_OriginalOwnerXuidHigh"].asInt();
	g_netvars::m_OriginalOwnerXuidLow = netvars["netvars"]["m_OriginalOwnerXuidLow"].asInt();
	g_netvars::m_SurvivalGameRuleDecisionTypes = netvars["netvars"]["m_SurvivalGameRuleDecisionTypes"].asInt();
	g_netvars::m_SurvivalRules = netvars["netvars"]["m_SurvivalRules"].asInt();
	g_netvars::m_aimPunchAngle = netvars["netvars"]["m_aimPunchAngle"].asInt();
	g_netvars::m_aimPunchAngleVel = netvars["netvars"]["m_aimPunchAngleVel"].asInt();
	g_netvars::m_bBombPlanted = netvars["netvars"]["m_bBombPlanted"].asInt();
	g_netvars::m_bFreezePeriod = netvars["netvars"]["m_bFreezePeriod"].asInt();
	g_netvars::m_bGunGameImmunity = netvars["netvars"]["m_bGunGameImmunity"].asInt();
	g_netvars::m_bHasDefuser = netvars["netvars"]["m_bHasDefuser"].asInt();
	g_netvars::m_bHasHelmet = netvars["netvars"]["m_bHasHelmet"].asInt();
	g_netvars::m_bInReload = netvars["netvars"]["m_bInReload"].asInt();
	g_netvars::m_bIsDefusing = netvars["netvars"]["m_bIsDefusing"].asInt();
	g_netvars::m_bIsQueuedMatchmaking = netvars["netvars"]["m_bIsQueuedMatchmaking"].asInt();
	g_netvars::m_bIsScoped = netvars["netvars"]["m_bIsScoped"].asInt();
	g_netvars::m_bIsValveDS = netvars["netvars"]["m_bIsValveDS"].asInt();
	g_netvars::m_bSpotted = netvars["netvars"]["m_bSpotted"].asInt();
	g_netvars::m_bSpottedByMask = netvars["netvars"]["m_bSpottedByMask"].asInt();
	g_netvars::m_clrRender = netvars["netvars"]["m_clrRender"].asInt();
	g_netvars::m_dwBoneMatrix = netvars["netvars"]["m_dwBoneMatrix"].asInt();
	g_netvars::m_fAccuracyPenalty = netvars["netvars"]["m_fAccuracyPenalty"].asInt();
	g_netvars::m_fFlags = netvars["netvars"]["m_fFlags"].asInt();
	g_netvars::m_flC4Blow = netvars["netvars"]["m_flC4Blow"].asInt();
	g_netvars::m_flDefuseCountDown = netvars["netvars"]["m_flDefuseCountDown"].asInt();
	g_netvars::m_flDefuseLength = netvars["netvars"]["m_flDefuseLength"].asInt();
	g_netvars::m_flFallbackWear = netvars["netvars"]["m_flFallbackWear"].asInt();
	g_netvars::m_flFlashDuration = netvars["netvars"]["m_flFlashDuration"].asInt();
	g_netvars::m_flFlashMaxAlpha = netvars["netvars"]["m_flFlashMaxAlpha"].asInt();
	g_netvars::m_flNextPrimaryAttack = netvars["netvars"]["m_flNextPrimaryAttack"].asInt();
	g_netvars::m_flTimerLength = netvars["netvars"]["m_flTimerLength"].asInt();
	g_netvars::m_hActiveWeapon = netvars["netvars"]["m_hActiveWeapon"].asInt();
	g_netvars::m_hMyWeapons = netvars["netvars"]["m_hMyWeapons"].asInt();
	g_netvars::m_hObserverTarget = netvars["netvars"]["m_hObserverTarget"].asInt();
	g_netvars::m_hOwner = netvars["netvars"]["m_hOwner"].asInt();
	g_netvars::m_hOwnerEntity = netvars["netvars"]["m_hOwnerEntity"].asInt();
	g_netvars::m_iAccountID = netvars["netvars"]["m_iAccountID"].asInt();
	g_netvars::m_iClip1 = netvars["netvars"]["m_iClip1"].asInt();
	g_netvars::m_iCompetitiveRanking = netvars["netvars"]["m_iCompetitiveRanking"].asInt();
	g_netvars::m_iCompetitiveWins = netvars["netvars"]["m_iCompetitiveWins"].asInt();
	g_netvars::m_iCrosshairId = netvars["netvars"]["m_iCrosshairId"].asInt();
	g_netvars::m_iEntityQuality = netvars["netvars"]["m_iEntityQuality"].asInt();
	g_netvars::m_iFOV = netvars["netvars"]["m_iFOV"].asInt();
	g_netvars::m_iFOVStart = netvars["netvars"]["m_iFOVStart"].asInt();
	g_netvars::m_iGlowIndex = netvars["netvars"]["m_iGlowIndex"].asInt();
	g_netvars::m_iHealth = netvars["netvars"]["m_iHealth"].asInt();
	g_netvars::m_iItemDefinitionIndex = netvars["netvars"]["m_iItemDefinitionIndex"].asInt();
	g_netvars::m_iItemIDHigh = netvars["netvars"]["m_iItemIDHigh"].asInt();
	g_netvars::m_iObserverMode = netvars["netvars"]["m_iObserverMode"].asInt();
	g_netvars::m_iShotsFired = netvars["netvars"]["m_iShotsFired"].asInt();
	g_netvars::m_iState = netvars["netvars"]["m_iState"].asInt();
	g_netvars::m_iTeamNum = netvars["netvars"]["m_iTeamNum"].asInt();
	g_netvars::m_lifeState = netvars["netvars"]["m_lifeState"].asInt();
	g_netvars::m_nFallbackPaintKit = netvars["netvars"]["m_nFallbackPaintKit"].asInt();
	g_netvars::m_nFallbackSeed = netvars["netvars"]["m_nFallbackSeed"].asInt();
	g_netvars::m_nFallbackStatTrak = netvars["netvars"]["m_nFallbackStatTrak"].asInt();
	g_netvars::m_nForceBone = netvars["netvars"]["m_nForceBone"].asInt();
	g_netvars::m_nTickBase = netvars["netvars"]["m_nTickBase"].asInt();
	g_netvars::m_rgflCoordinateFrame = netvars["netvars"]["m_rgflCoordinateFrame"].asInt();
	g_netvars::m_szCustomName = netvars["netvars"]["m_szCustomName"].asInt();
	g_netvars::m_szLastPlaceName = netvars["netvars"]["m_szLastPlaceName"].asInt();
	g_netvars::m_thirdPersonViewAngles = netvars["netvars"]["m_thirdPersonViewAngles"].asInt();
	g_netvars::m_vecOrigin = netvars["netvars"]["m_vecOrigin"].asInt();
	g_netvars::m_vecVelocity = netvars["netvars"]["m_vecVelocity"].asInt();
	g_netvars::m_vecViewOffset = netvars["netvars"]["m_vecViewOffset"].asInt();
	g_netvars::m_viewPunchAngle = netvars["netvars"]["m_viewPunchAngle"].asInt();
}

int main(int, char**)
{
	D3D11_BLEND_DESC desc;
	ZeroMemory(&desc, sizeof(desc));

	LPCSTR curdir = _T("./Config.ini");
    // Create application window
    WNDCLASSEX wc = { sizeof(WNDCLASSEX), CS_HREDRAW | CS_VREDRAW, WndProc, 0, 0, GetModuleHandle(NULL), LoadIcon(NULL, IDI_APPLICATION), LoadCursor(NULL, IDC_ARROW), (HBRUSH)CreateSolidBrush(RGB(0, 0, 0)), NULL, _T("ImGui Example"), NULL };
    RegisterClassEx(&wc);
	XOR(HWND hwnd = CreateWindow(_T("ImGui Example"), _T("Avustaja"), WS_POPUP | WS_EX_TOPMOST, 1000, 0, 1920, 600, NULL, NULL, wc.hInstance, NULL));
	//HWND hwnd = FindWindow(0, "Counter-Strike: Global Offensive");
	XOR(ShowWindow(::GetConsoleWindow(), SW_HIDE));
	SetLayeredWindowAttributes(hwnd, 0, 0, LWA_ALPHA);
	SetLayeredWindowAttributes(hwnd, 0, RGB(0, 0, 0), LWA_COLORKEY);

	MARGINS Margin = { -1, -1, -1, -1 };
	XOR(DwmExtendFrameIntoClientArea(hwnd, &Margin));

    // Initialize Direct3D
    if (CreateDeviceD3D(hwnd) < 0)
    {
        CleanupDeviceD3D();
        //UnregisterClass(_T("ImGui Example"), wc.hInstance);
        return 1;
    }


    // Show the window
    XOR(ShowWindow(hwnd, SW_SHOWDEFAULT));
    UpdateWindow(hwnd);
    // Setup Dear ImGui context
    IMGUI_CHECKVERSION();
    ImGui::CreateContext();
    ImGuiIO& io = ImGui::GetIO(); (void)io;
    //io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;  // Enable Keyboard Controls
	io.IniFilename = NULL;
	dankmemeforthewin();
    // Setup Dear ImGui style
    ImGui::StyleColorsDark();
    //ImGui::StyleColorsClassic();

    // Setup Platform/Renderer bindings
    ImGui_ImplWin32_Init(hwnd);
    ImGui_ImplDX11_Init(g_pd3dDevice, g_pd3dDeviceContext);

    // Load Fonts
    // - If no fonts are loaded, dear imgui will use the default font. You can also load multiple fonts and use ImGui::PushFont()/PopFont() to select them. 
    // - AddFontFromFileTTF() will return the ImFont* so you can store it if you need to select the font among multiple. 
    // - If the file cannot be loaded, the function will return NULL. Please handle those errors in your application (e.g. use an assertion, or display an error and quit).
    // - The fonts will be rasterized at a given size (w/ oversampling) and stored into a texture when calling ImFontAtlas::Build()/GetTexDataAsXXXX(), which ImGui_ImplXXXX_NewFrame below will call.
    // - Read 'misc/fonts/README.txt' for more instructions and details.
    // - Remember that in C/C++ if you want to include a backslash \ in a string literal you need to write a double backslash \\ !
    //io.Fonts->AddFontDefault();
    //io.Fonts->AddFontFromFileTTF("../../misc/fonts/Roboto-Medium.ttf", 16.0f);
    //io.Fonts->AddFontFromFileTTF("../../misc/fonts/Cousine-Regular.ttf", 15.0f);
    //io.Fonts->AddFontFromFileTTF("../../misc/fonts/DroidSans.ttf", 16.0f);
    //io.Fonts->AddFontFromFileTTF("../../misc/fonts/ProggyTiny.ttf", 10.0f);
    //ImFont* font = io.Fonts->AddFontFromFileTTF("c:\\Windows\\Fonts\\ArialUni.ttf", 18.0f, NULL, io.Fonts->GetGlyphRangesJapanese());
    //IM_ASSERT(font != NULL);

    // Our state
	
	GetPrivateProfileString("user", "Bunnyhop", "false", BunnyINI, 10, curdir);
	GetPrivateProfileString("user", "Autofire", "false", FireINI, 10, curdir);
	GetPrivateProfileString("user", "Wallhack", "false", WallINI, 10, curdir);
	GetPrivateProfileString("user", "Triggerbot", "false", TriggerINI, 10, curdir);
	GetPrivateProfileString("user", "Noflash", "false", FlashINI, 10, curdir);
	GetPrivateProfileString("user", "RadarHack", "false", RadarINI, 10, curdir);
	XOR(bool Bbunnyhop = Parser(BunnyINI));
	XOR(bool Bautofire = Parser(FireINI));
	XOR(bool Bwallhack = Parser(WallINI));
	XOR(bool Btriggerbot = Parser(TriggerINI));
	XOR(bool Bnoflash = Parser(FlashINI));
	XOR(bool xWalltoggle = false);
	XOR(bool xWalltoggle2 = false);
	bool Basdasdlol = false;
	XOR(bool Bradar = Parser(RadarINI));

	XOR(ImVec2 exitbutton = ImVec2(100, 30));
	XOR(ImVec2 refresh = ImVec2(150, 30));
	XOR(ImVec4 clear_color = ImVec4(0.0f, 0.0f, 0.0f, 0.0f));
	float Cham_color[4] = { 0, 0, 0, 0 };
	//float Cham_color[3] = { 255.0f, 255.0f, 255.0f};
	float clearColor[4] = { 0.0f,0.0f,0.0f,0.0f };
	XOR(HWND hcsgond = FindWindow(NULL, "Counter-Strike: Global Offensive"));
	init();
	update();
	//Set the global var for localplayer base address to reduce RPM calls
	LocalPlayer::setLocalPlayer();
	//LocalPlayer::setLocalPlayerEng();
	clientState = rpm<DWORD>(engineAddress + g_offsets::dwClientState);

	// Main loop
	MSG msg;
	bool lol = false;
	ZeroMemory(&msg, sizeof(msg));
	dankmemeforthewin();
	HANDLE bhop = NULL;
	HANDLE aim = NULL;
	HANDLE Trigger = NULL;
	int lore = 0;
	const char* items[] = { "Left ALT", "Scroll Down", "Mouse2" };
	const char* current_item = items[0];
	while (msg.message != WM_QUIT || !GetAsyncKeyState(VK_F10))
	{
					
		if (SigOnState() == 6)
		{
			LocalPlayer::setLocalPlayer();
			//LocalPlayer::setLocalPlayerEng();
		}
		dankmemeforthewin();
		dankmemeforthewin();
		dankmemeforthewin();
		// Poll and handle messages (inputs, window resize, etc.)
		// You can read the io.WantCaptureMouse, io.WantCaptureKeyboard flags to tell if dear imgui wants to use your inputs.
		// - When io.WantCaptureMouse is true, do not dispatch mouse input data to your main application.
		// - When io.WantCaptureKeyboard is true, do not dispatch keyboard input data to your main application.
		// Generally you may always pass all inputs to dear imgui, and hide them from your application based on those two flags.
		if (PeekMessage(&msg, NULL, 0U, 0U, PM_REMOVE))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
			continue;
		}
		if (GetAsyncKeyState(VK_INSERT) & 1)
		{
			lol = !lol;
			Sleep(100);
			XOR(ChangeClickability(lol, hwnd));

			if (lol == false)
			{
				XOR(SetForegroundWindow(hcsgond));
			}
		}

		if (Btriggerbot)
		{
			if (Trigger == NULL)
			{
				dankmemeforthewin();
				XOR(Trigger = CreateThread(NULL, NULL, &Koodi::Triggerbot, NULL, NULL, NULL));
			}
		}

		if (!Btriggerbot)
		{
			if (Trigger != NULL)
			{
				XOR(TerminateThread(Trigger, 0));
			}
		}
					


		if (Bautofire)
		{
			dankmemeforthewin();
			XOR(Koodi::autopistol());
		}

		if (Bradar)
		{
			for (int i = 0; i < 32; i++)
			{
				XOR(auto base = Entity::getEntBase(i));
				dankmemeforthewin();
				dankmemeforthewin();
				XOR(Entity::setSpotted(base, true));
			}
		}

		if (Bwallhack || xWalltoggle && xWalltoggle2)
		{
			dankmemeforthewin();
			XOR(Koodi::ESP());
		}

		if (GetAsyncKeyState(VK_NUMPAD0) & 1) {
			xWalltoggle = !xWalltoggle;
		}

		if (Bnoflash)
		{
			XOR(Koodi::noFlash());
		}

		if (Bbunnyhop)
		{
			if (bhop == NULL)
			{
				XOR(bhop = CreateThread(NULL, NULL, &Koodi::Bunnyhop, NULL, NULL, NULL));
			}
		}

		if(!Bbunnyhop)
		{
			XOR(TerminateThread(bhop, 0));
			XOR(bhop = NULL);
		}

		// Start the Dear ImGui frame
		ImGui_ImplDX11_NewFrame();
		ImGui_ImplWin32_NewFrame();
		ImGui::NewFrame();

		// 1. Show the big demo window (Most of the sample code is in ImGui::ShowDemoWindow()! You can browse its code to learn more about Dear ImGui!).

		// 2. Show a simple window that we create ourselves. We use a Begin/End pair to created a named window.
		{
			static float f = 0.0f;
			static int counter = 0;

			ImGui::Begin("CS:GO eXternal 2.0 & Autoupdater 7.6.2020");                          // Create a window called "Hello, world!" and append into it.
			ImGui::Text("Press Insert To hide and show  menu");

			ImGui::Checkbox("Bunnyhop         ", &Bbunnyhop);     // Edit bools storing our window open/close state
			ImGui::SameLine();
			ImGui::Checkbox("Autopistol", &Bautofire);
			ImGui::Checkbox("Radar Hack       ", &Bradar);
			ImGui::SameLine();
			ImGui::Checkbox("Wallhack", &Bwallhack);
			ImGui::SameLine();
			ImGui::Checkbox("WToggle", &xWalltoggle2);
			ImGui::Checkbox("Triggerbot", &Btriggerbot);
			//ImGui::Checkbox("asdasdlol", &Basdasdlol);
			if (Trigger)
			{
					ImGui::SameLine();
					if (ImGui::BeginCombo("Hotkey", current_item)) // The second parameter is the label previewed before opening the combo.
					{
						for (int n = 0; n < IM_ARRAYSIZE(items); n++)
						{
							bool is_selected = (current_item == items[n]); // You can store your selection however you want, outside or inside your objects
							if (ImGui::Selectable(items[n], is_selected))
							{
								current_item = items[n];
								XOR(LocalPlayer::setLocalTriggerKey(current_item));
								if (is_selected)
									ImGui::SetItemDefaultFocus();   // You may set the initial focus when opening the combo (scrolling + for keyboard navigation support)
							}
						}
						ImGui::EndCombo();
					}
			}

			ImGui::Checkbox("NoFlash", &Bnoflash);
			ImGui::NewLine();
			ImGui::NewLine();
			if (ImGui::Button("EXIT Cheat", exitbutton))
			{
				ImGui_ImplDX11_Shutdown();
				ImGui_ImplWin32_Shutdown();
				ImGui::DestroyContext();

				CleanupDeviceD3D();
				DestroyWindow(hwnd);
				CloseHandle(hProc);
				UnregisterClass(_T("ImGui Example"), wc.hInstance);
				Sleep(100);
				return 0;
			}
			ImGui::SameLine();
			if (ImGui::Button("Refresh offsets", refresh))
			{
				LocalPlayer::setLocalPlayer();
				//LocalPlayer::setLocalPlayerEng();
				std::cout << LocalPlayer::getLocalPlayer() << std::endl;
			}

			if (Bbunnyhop) {
				ImGui::Text("FLAGS: %i", LocalPlayer::getLocalFlags());
			}
			if(Bautofire)
			{
				float accpen = rpm<float>(clientState + g_netvars::m_fAccuracyPenalty);
				ImGui::Text("PEANLTY: %f", accpen);
				ImGui::Text("WEAPON: %i", Koodi::currentWeapon());
			}

			ImGui::Text("Application average %.3f ms/frame (%.1f FPS)", 1000.0f / ImGui::GetIO().Framerate, ImGui::GetIO().Framerate);
			ImGui::Text("LocalTeamID %i", LocalPlayer::getLocalTeam());
			ImGui::End();
		}

		if (Basdasdlol)
		{
			ImGui::Begin("Another Window", &Basdasdlol);   // Pass a pointer to our bool variable (the window will have a closing button that will clear the bool when clicked)
			ImGui::Text("Hello from another window!");
			ImGui::ColorEdit3("Enemy Color!", (float*)&Cham_color);
			//Koodi::Chams(Cham_color[0]/10000000, Cham_color[1]/10000000, Cham_color[2]/10000000);
			ImGui::End();
		}

		// Rendering
		ImGui::Render();
		g_pd3dDeviceContext->OMSetRenderTargets(1, &g_mainRenderTargetView, NULL);
		g_pd3dDeviceContext->ClearRenderTargetView(g_mainRenderTargetView, (float*)&clearColor);
		ImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData());

		g_pSwapChain->Present(1, 0); // Present with vsync
		//g_pSwapChain->Present(0, 0); // Present without vsync
		Sleep(1);
	}

    ImGui_ImplDX11_Shutdown();
    ImGui_ImplWin32_Shutdown();
    ImGui::DestroyContext();

    CleanupDeviceD3D();
    DestroyWindow(hwnd);
    UnregisterClass(_T("ImGui Example"), wc.hInstance);
	CloseHandle(hProc);
    return 0;
}
