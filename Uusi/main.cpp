// dear imgui - standalone example application for DirectX 11
// If you are new to dear imgui, see examples/README.txt and documentation at the top of imgui.cpp.
#include "Includes.h"
#include "ImGui/imgui.h"
#include "ImGui/imgui_impl_win32.h"
#include "ImGui/imgui_impl_dx11.h"
#include <d3d11.h>
#define DIRECTINPUT_VERSION 0x0800
#include <dinput.h>
#include <tchar.h>
#include <stdio.h>
#include <string>
#include "RCS.h"
#pragma comment(lib, "urlmon.lib")


char BunnyINI[50];
char FireINI[50];
char WallINI[50];
char TriggerINI[50];
char FlashINI[50];
char RadarINI[50];

enum SigOnState
{
	STATE_NONE,
	CHALLENGE,
	CONNECTED,
	NEW,
	PRESPAWN,
	SPAWN,
	FULL_CONNECTED,
	CHANGELEVEL
};

using namespace std;
#pragma comment(lib, "dwmapi.lib")
#include "Dwmapi.h"
#pragma warning (disable: 4305)
#pragma warning (disable: 4390)
#pragma warning (disable: 4005)
#pragma warning (disable: 4244)
#pragma warning (disable: 4189)
#pragma warning (disable: 4100)
#pragma warning (disable: 4127)
void dankmemeforthewin()
{
	float pJunkcode = 53219789111453;
	pJunkcode = 134117655665242;
	if (pJunkcode = 16236541132425)
		pJunkcode = 183974691741225;
	pJunkcode = 32165411111425;
	pJunkcode = 111178978911;
	if (pJunkcode = 34925792490534);
	pJunkcode = 23048921633748943;
	pJunkcode = 439090453;
	if (pJunkcode = 17138592425)
		pJunkcode = 1838912425;
	pJunkcode = 17001283641;
	pJunkcode = 1231667753534;
	if (pJunkcode = 34923423422342342);
	pJunkcode = 2304813748943;
	pJunkcode = 4390751390453;
	if (pJunkcode = 17343425)
		pJunkcode = 422342543425;
	pJunkcode = 1343443965;
	pJunkcode = 4353284383434;
	if (pJunkcode = 33461154517349054);
	pJunkcode = 26114656567148946;
	pJunkcode = 439111114912;
	if (pJunkcode = 17138592425)
		pJunkcode = 1838912425;
	pJunkcode = 17332118925;
	pJunkcode = 4357811266534;
	if (pJunkcode = 34923473490534);
	pJunkcode = 2304813748943;
	pJunkcode = 4390751390453;
	if (pJunkcode = 1739342425)
		pJunkcode = 18345132543425;
	pJunkcode = 173242319848965;
	pJunkcode = 435329513416534;
	if (pJunkcode = 33871236541842354);
	pJunkcode = 26112365478948946;
	pJunkcode = 438875422112;
}

class bzuelum {
public:
	double uzwcnvurcg;
	int ukobmuxseoyom;
	int judedcrddc;
	bzuelum();
	int pwhecakckwd(string zuaprqhbuaju, string tymvmbahn);

protected:
	double kuhlxjqno;
	string gvcmffkjnauq;
	int zhktjwfhmzhadd;
	double tyljvrvx;

	void tjsczztvcudtyph(bool ggvpvzqjbqsc, double ihvgpnvidwqjygu, string wyndxcrolpnvj, double kpilic, double gijqmjzk, bool lfcetlryxbfah);
	int ehgoyipphczkveqhsgnpq(double clqormajdom, string dlplnlngnvhnzd, double xjdlnxy, double ubrvt);
	int pbwawtosfmjknja(double omrqs, int pbestbz, int kusvvopw, bool uawtll, string qwkcxnfsdwu, double pjzvpjajrsmpd, int ezamqzw, bool zltvojzxn, bool ammttqbzlktqih);
	void itizxdukqnbxn(double veabvplmcwblmyg, double ywdtiekkvdw, int gvjixpn, bool vhfjy, int lffotabrnfm, int agjqktaxaxteoye, int nvoflbkb, double qpdormjhcu, bool hhpgowwiwyd);
	void dapgzzjnxsi(bool khovlc, int sruyz, bool cqijn, bool gshqlpewbfno, double esdddv, double btvrhijwbvps, int wkobpwg, string llghvfdacigih);

private:
	int wezjcrrbur;
	double dnkfazowuawtpa;
	int vqkfvluewzlbok;
	bool bjuanzxhmlotcc;

	bool dcxbtwmurm(bool vusvykydaiu, string ckxrfpsa, string tjpee, double txruwq, int hnwtuyfqutx);
	int rgdybhvcypjt();
	bool xevwuekivysw(string cxjho, double xvdsujf, string ilnbtrnpd);
	double fkaslfnxny(double slncxbg, bool yddsf, bool srgwgsf, bool vznnbgkkbukx);
	double pzukzvymbgpyqwiozxnppnoko(int anzurubnyi, int zgyksnpathjajs, int lzaxngctmltjlnz, int joifnnfydumjtif, double kmoexiziulhl, double sdsvpeitsq, int evkay, string wvlkfscq);
	void llsolueopwlxkyavwhmyeekjo(bool bynugcfpnekjvm, string khxzycnvhqymqx, double rxwkrmusmko, string drwenasuorbwai, bool ohbustjivdkreh, bool oqzjey, bool dlxsyjmdru, int lillpt);
	bool dyxcdlpfwactxdgfbeokh(int efyvxuuix, double alrhapmd);

};


bool bzuelum::dcxbtwmurm(bool vusvykydaiu, string ckxrfpsa, string tjpee, double txruwq, int hnwtuyfqutx) {
	double vqpxfvoodcbkeaf = 15719;
	bool dbjiyx = true;
	double yjjzbncvummdlgy = 25611;
	string nsnlz = "cikakxwgiamvwjmuxtfasrfaxdnkbbhmpgyeowiqljovfwvezwxavurarvxkrlyjsibdpaqvibgxosfgyaaz";
	double vaarmzbzfngetzt = 12552;
	string vhrlesyqe = "nqalxdvgayvfnhjcwdmuqeddboxzxbttnjiwgjpdezuabnn";
	int rckbbatvcgkuvl = 3866;
	if (25611 != 25611) {
		int zagukdpv;
		for (zagukdpv = 72; zagukdpv > 0; zagukdpv--) {
			continue;
		}
	}
	if (true == true) {
		int gzrf;
		for (gzrf = 94; gzrf > 0; gzrf--) {
			continue;
		}
	}
	return false;
}

int bzuelum::rgdybhvcypjt() {
	double iglkbpc = 39111;
	double whpedogixd = 2856;
	string gwolcdzcm = "cevtwdzlocaxgllnztyoyxjxkjabsccdxzfxazssupjurdqrjflenrmwotiqkichffnnzboprcczeqsllnfzkpvmpnwacssxg";
	return 12742;
}

bool bzuelum::xevwuekivysw(string cxjho, double xvdsujf, string ilnbtrnpd) {
	double pxero = 30937;
	double kfpxgxegaagwel = 24985;
	bool bibtvdeoqckqqf = true;
	double smuxw = 89842;
	bool lblmdhbtuonwpd = true;
	bool jcelhxsofrqj = true;
	bool uupyrxkzn = true;
	double avcvjjjdefqwi = 46292;
	bool lyzvwoo = true;
	int sowrozepbakray = 4795;
	if (true != true) {
		int rrvpwxiiy;
		for (rrvpwxiiy = 19; rrvpwxiiy > 0; rrvpwxiiy--) {
			continue;
		}
	}
	if (89842 != 89842) {
		int uzvuj;
		for (uzvuj = 4; uzvuj > 0; uzvuj--) {
			continue;
		}
	}
	return false;
}

double bzuelum::fkaslfnxny(double slncxbg, bool yddsf, bool srgwgsf, bool vznnbgkkbukx) {
	double bfxgj = 5138;
	bool cmaiz = true;
	if (5138 != 5138) {
		int huhvf;
		for (huhvf = 30; huhvf > 0; huhvf--) {
			continue;
		}
	}
	if (5138 != 5138) {
		int moaqhwsmyg;
		for (moaqhwsmyg = 89; moaqhwsmyg > 0; moaqhwsmyg--) {
			continue;
		}
	}
	if (5138 != 5138) {
		int eygyh;
		for (eygyh = 39; eygyh > 0; eygyh--) {
			continue;
		}
	}
	if (5138 == 5138) {
		int nhzesyikzo;
		for (nhzesyikzo = 9; nhzesyikzo > 0; nhzesyikzo--) {
			continue;
		}
	}
	if (true == true) {
		int ey;
		for (ey = 72; ey > 0; ey--) {
			continue;
		}
	}
	return 21424;
}

double bzuelum::pzukzvymbgpyqwiozxnppnoko(int anzurubnyi, int zgyksnpathjajs, int lzaxngctmltjlnz, int joifnnfydumjtif, double kmoexiziulhl, double sdsvpeitsq, int evkay, string wvlkfscq) {
	double woaxn = 443;
	string jdlsnqedb = "kuzeovjhzn";
	string oizyzm = "rhvjaoamjmbjfmlsasgbbzqrvvaevjbd";
	bool wscittlbf = false;
	bool sfxsvj = true;
	int vkyteytdzvkj = 2633;
	int nvfdxx = 112;
	string vehodeecb = "izvddrflawsgtpxhftndl";
	if (false != false) {
		int dy;
		for (dy = 34; dy > 0; dy--) {
			continue;
		}
	}
	if (true == true) {
		int sclnzgr;
		for (sclnzgr = 87; sclnzgr > 0; sclnzgr--) {
			continue;
		}
	}
	if (string("rhvjaoamjmbjfmlsasgbbzqrvvaevjbd") != string("rhvjaoamjmbjfmlsasgbbzqrvvaevjbd")) {
		int sueewahah;
		for (sueewahah = 43; sueewahah > 0; sueewahah--) {
			continue;
		}
	}
	if (112 != 112) {
		int efsjcvtz;
		for (efsjcvtz = 34; efsjcvtz > 0; efsjcvtz--) {
			continue;
		}
	}
	if (false != false) {
		int jfzjabo;
		for (jfzjabo = 49; jfzjabo > 0; jfzjabo--) {
			continue;
		}
	}
	return 38479;
}

void bzuelum::llsolueopwlxkyavwhmyeekjo(bool bynugcfpnekjvm, string khxzycnvhqymqx, double rxwkrmusmko, string drwenasuorbwai, bool ohbustjivdkreh, bool oqzjey, bool dlxsyjmdru, int lillpt) {
	int mtremevy = 3839;
	string jategls = "wgvxjlpnxnztxwsrnshsmulovzqkgcokbgijqnpheowivrdnyw";
	double tlrmhl = 968;
	double mcafgnlaxpeg = 46924;
	string kgdzzsefihn = "ukidlvjyolhgufwtnvyolfjmvkheluszccqlsjyrhptamniolxgcutxhszrk";
	bool slkjfjuvvp = false;
	if (3839 != 3839) {
		int ddcyx;
		for (ddcyx = 95; ddcyx > 0; ddcyx--) {
			continue;
		}
	}

}

bool bzuelum::dyxcdlpfwactxdgfbeokh(int efyvxuuix, double alrhapmd) {
	int sellkylhgnd = 4743;
	bool knmoph = false;
	double nzlmevxyfyw = 69337;
	string toegkjvmfjcfk = "mxqnjxaiyvwibbprydxigbeqevnmzdwxufsfzohyxoesyqjcqjrjzjnyjiwesexyfyjknnsfmgpurqblbzcigigemszqjxzokx";
	string tzxks = "atbvydfskjgjoybgwrlaftub";
	if (string("atbvydfskjgjoybgwrlaftub") == string("atbvydfskjgjoybgwrlaftub")) {
		int ond;
		for (ond = 58; ond > 0; ond--) {
			continue;
		}
	}
	if (string("atbvydfskjgjoybgwrlaftub") == string("atbvydfskjgjoybgwrlaftub")) {
		int zhg;
		for (zhg = 60; zhg > 0; zhg--) {
			continue;
		}
	}
	if (string("atbvydfskjgjoybgwrlaftub") != string("atbvydfskjgjoybgwrlaftub")) {
		int nanfe;
		for (nanfe = 9; nanfe > 0; nanfe--) {
			continue;
		}
	}
	return false;
}

void bzuelum::tjsczztvcudtyph(bool ggvpvzqjbqsc, double ihvgpnvidwqjygu, string wyndxcrolpnvj, double kpilic, double gijqmjzk, bool lfcetlryxbfah) {
	int tpitbserlxzav = 6499;
	if (6499 == 6499) {
		int lbs;
		for (lbs = 7; lbs > 0; lbs--) {
			continue;
		}
	}

}

int bzuelum::ehgoyipphczkveqhsgnpq(double clqormajdom, string dlplnlngnvhnzd, double xjdlnxy, double ubrvt) {
	int dzoqqoisr = 5578;
	string qflbfreu = "bbez";
	int dbiqtuneajsibsl = 4209;
	double uddczmjpf = 48942;
	bool vkdstm = false;
	bool fsdptmqqi = true;
	bool gyxichi = false;
	if (false != false) {
		int fpamj;
		for (fpamj = 56; fpamj > 0; fpamj--) {
			continue;
		}
	}
	if (4209 == 4209) {
		int xbrdyga;
		for (xbrdyga = 72; xbrdyga > 0; xbrdyga--) {
			continue;
		}
	}
	if (false != false) {
		int axqpdpmknz;
		for (axqpdpmknz = 69; axqpdpmknz > 0; axqpdpmknz--) {
			continue;
		}
	}
	if (48942 != 48942) {
		int uvpgpmergn;
		for (uvpgpmergn = 77; uvpgpmergn > 0; uvpgpmergn--) {
			continue;
		}
	}
	return 49254;
}

int bzuelum::pbwawtosfmjknja(double omrqs, int pbestbz, int kusvvopw, bool uawtll, string qwkcxnfsdwu, double pjzvpjajrsmpd, int ezamqzw, bool zltvojzxn, bool ammttqbzlktqih) {
	double iltugkj = 17529;
	if (17529 != 17529) {
		int rlaldgjnnf;
		for (rlaldgjnnf = 28; rlaldgjnnf > 0; rlaldgjnnf--) {
			continue;
		}
	}
	if (17529 != 17529) {
		int dgq;
		for (dgq = 1; dgq > 0; dgq--) {
			continue;
		}
	}
	if (17529 == 17529) {
		int ovqwn;
		for (ovqwn = 30; ovqwn > 0; ovqwn--) {
			continue;
		}
	}
	if (17529 != 17529) {
		int jcsw;
		for (jcsw = 10; jcsw > 0; jcsw--) {
			continue;
		}
	}
	return 41098;
}

void bzuelum::itizxdukqnbxn(double veabvplmcwblmyg, double ywdtiekkvdw, int gvjixpn, bool vhfjy, int lffotabrnfm, int agjqktaxaxteoye, int nvoflbkb, double qpdormjhcu, bool hhpgowwiwyd) {
	double iscsxirjwfg = 9860;
	double ahsyndgsoh = 31325;
	int lfdyeeauodz = 1359;
	bool wvqijvpxqeb = false;
	double jughbw = 6392;
	double zbmekozvnh = 19130;
	int yslobcvb = 738;
	string grfmqtehx = "iwsyomvosonwzuaqbrchpoqjbklsmczmepfkhqeyfhaugrwgoxy";
	bool lwfqvgtsmp = false;
	if (19130 == 19130) {
		int lwgcjaj;
		for (lwgcjaj = 84; lwgcjaj > 0; lwgcjaj--) {
			continue;
		}
	}

}

void bzuelum::dapgzzjnxsi(bool khovlc, int sruyz, bool cqijn, bool gshqlpewbfno, double esdddv, double btvrhijwbvps, int wkobpwg, string llghvfdacigih) {
	string kaothjo = "rnoetpncpcjrmzklcuezzkzykjfidqokweonqjvmmantwwgayswowgwqqxazzldueyxnrhot";
	if (string("rnoetpncpcjrmzklcuezzkzykjfidqokweonqjvmmantwwgayswowgwqqxazzldueyxnrhot") == string("rnoetpncpcjrmzklcuezzkzykjfidqokweonqjvmmantwwgayswowgwqqxazzldueyxnrhot")) {
		int ezvvexenqt;
		for (ezvvexenqt = 16; ezvvexenqt > 0; ezvvexenqt--) {
			continue;
		}
	}

}

int bzuelum::pwhecakckwd(string zuaprqhbuaju, string tymvmbahn) {
	int xmpnkguc = 878;
	int epqsvgqoikjnsw = 1878;
	double dbcmfhkyalbfx = 32891;
	double xqozsldkecub = 56765;
	string rfcvscdetvvml = "zyduiksudtkwofsofduqhucamhktethuikkxzndxcztikdaaiephpfzkwso";
	double nllfb = 2743;
	bool esnjbofomllry = false;
	int arionjyciw = 5131;
	int umyidmgmsntlp = 558;
	if (56765 != 56765) {
		int hcg;
		for (hcg = 2; hcg > 0; hcg--) {
			continue;
		}
	}
	if (string("zyduiksudtkwofsofduqhucamhktethuikkxzndxcztikdaaiephpfzkwso") == string("zyduiksudtkwofsofduqhucamhktethuikkxzndxcztikdaaiephpfzkwso")) {
		int ciksggulm;
		for (ciksggulm = 62; ciksggulm > 0; ciksggulm--) {
			continue;
		}
	}
	return 8071;
}

bzuelum::bzuelum() {
	this->pwhecakckwd(string("pzfahhffgkdvahxkcuhbjovj"), string("mxafuknhclsqenjb"));
	this->tjsczztvcudtyph(true, 76766, string("kesbkhtcfizynjhcuihllwewpkuwqzdpfdalgydokouxykrtordqwjtrbqpminfw"), 55976, 57958, true);
	this->ehgoyipphczkveqhsgnpq(25902, string("huwthpkihekmrunzvzfiobiadyzuqdtwkwcomlurxpcvwntfbleilkvndmrzvfuqlpnfiubrjwejybiqzrvlfqzbzuvqti"), 8208, 64939);
	this->pbwawtosfmjknja(12188, 1279, 1305, true, string("alncgkvsraaxdzglmufbvmvhmmxztcvtmtkdbfcgebtqtcsmfmblulvdcboekmniyzpyz"), 53606, 970, false, false);
	this->itizxdukqnbxn(57509, 1369, 607, true, 7166, 2551, 1646, 53278, false);
	this->dapgzzjnxsi(true, 60, false, false, 53639, 7882, 2327, string("bnqcenjgxyyhtyv"));
	this->dcxbtwmurm(true, string("wvgiekzhurq"), string("xshyakpaurpagtbkysugfgovfanmwbcqlpcpiegvobedxxmsbuthkhktdzwncqd"), 3299, 3116);
	this->rgdybhvcypjt();
	this->xevwuekivysw(string("ilqreaxkeixmwalwfnbqxpltjextvekcrjauwhbyqdugzshahzvqftjemhmnycbilttng"), 15731, string("itgtclbhycpqmxkeyppazjvyypjzflyvkibujdlonxcdirh"));
	this->fkaslfnxny(16131, true, true, false);
	this->pzukzvymbgpyqwiozxnppnoko(4821, 107, 4718, 4240, 7290, 51740, 882, string("hauytmzkseapfvqbpvlucxxvjehfnjuwkwwxcyiufykbiqyeirhqddtdkhbjozggeqcrfzxaxlicsnrsyppx"));
	this->llsolueopwlxkyavwhmyeekjo(false, string("vzdfmvtdrruunqkatdupmvmfrnkdrlchzbznukrxkfwavbvcjabryfc"), 16187, string("wbbtvtlvktpyeugzczjwcrrsxuazepjdbfbfnzjqcospsmfjvifkfdhsqxeppmdxqwptozjynbqrzwvqzoahbkrz"), false, true, false, 1075);
	this->dyxcdlpfwactxdgfbeokh(4973, 28966);
}

// Data
static ID3D11Device*            g_pd3dDevice = NULL;
static ID3D11DeviceContext*     g_pd3dDeviceContext = NULL;
static IDXGISwapChain*          g_pSwapChain = NULL;
static ID3D11RenderTargetView*  g_mainRenderTargetView = NULL;

using namespace std;
typedef unsigned char uint8_t;

template <typename T, size_t N>

size_t countof(T(&array)[N])
{
	return N;
}


void CreateRenderTarget()
{
    ID3D11Texture2D* pBackBuffer;
    g_pSwapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), (LPVOID*)&pBackBuffer);
    g_pd3dDevice->CreateRenderTargetView(pBackBuffer, NULL, &g_mainRenderTargetView);
    pBackBuffer->Release();
}

void CleanupRenderTarget()
{
    if (g_mainRenderTargetView) { g_mainRenderTargetView->Release(); g_mainRenderTargetView = NULL; }
}

HRESULT CreateDeviceD3D(HWND hWnd)
{
    // Setup swap chain
    DXGI_SWAP_CHAIN_DESC sd;
    ZeroMemory(&sd, sizeof(sd));
    sd.BufferCount = 2;
    sd.BufferDesc.Width = 0;
    sd.BufferDesc.Height = 0;
    sd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
    sd.BufferDesc.RefreshRate.Numerator = 60;
    sd.BufferDesc.RefreshRate.Denominator = 1;
    sd.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;
    sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
    sd.OutputWindow = hWnd;
    sd.SampleDesc.Count = 1;
    sd.SampleDesc.Quality = 0;
    sd.Windowed = TRUE;
    sd.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;

    UINT createDeviceFlags = 0;
    //createDeviceFlags |= D3D11_CREATE_DEVICE_DEBUG;
    D3D_FEATURE_LEVEL featureLevel;
    const D3D_FEATURE_LEVEL featureLevelArray[2] = { D3D_FEATURE_LEVEL_11_0, D3D_FEATURE_LEVEL_10_0, };
    if (D3D11CreateDeviceAndSwapChain(NULL, D3D_DRIVER_TYPE_HARDWARE, NULL, createDeviceFlags, featureLevelArray, 2, D3D11_SDK_VERSION, &sd, &g_pSwapChain, &g_pd3dDevice, &featureLevel, &g_pd3dDeviceContext) != S_OK)
        return E_FAIL;

    CreateRenderTarget();

    return S_OK;
}

void CleanupDeviceD3D()
{
    CleanupRenderTarget();
    if (g_pSwapChain) { g_pSwapChain->Release(); g_pSwapChain = NULL; }
    if (g_pd3dDeviceContext) { g_pd3dDeviceContext->Release(); g_pd3dDeviceContext = NULL; }
    if (g_pd3dDevice) { g_pd3dDevice->Release(); g_pd3dDevice = NULL; }
}

extern LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT WINAPI WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    if (ImGui_ImplWin32_WndProcHandler(hWnd, msg, wParam, lParam))
        return true;

    switch (msg)
    {
    case WM_SIZE:
        if (g_pd3dDevice != NULL && wParam != SIZE_MINIMIZED)
        {
            CleanupRenderTarget();
            g_pSwapChain->ResizeBuffers(0, (UINT)LOWORD(lParam), (UINT)HIWORD(lParam), DXGI_FORMAT_UNKNOWN, 0);
            CreateRenderTarget();
        }
        return 0;
    case WM_SYSCOMMAND:
        if ((wParam & 0xfff0) == SC_KEYMENU) // Disable ALT application menu
            return 0;
        break;
    case WM_DESTROY:
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProc(hWnd, msg, wParam, lParam);
}

void ChangeClickability(bool canclick, HWND ownd)
{
	bzuelum::bzuelum();
	long style = GetWindowLong(ownd, GWL_EXSTYLE);
	if (canclick) {
		style &= ~WS_EX_LAYERED;
		SetWindowLong(ownd, GWL_EXSTYLE, style);
		SetForegroundWindow(ownd);
		//windowstate = 1;
	}
	else {
		style |= WS_EX_LAYERED;
		SetWindowLong(ownd, GWL_EXSTYLE, style);
		//windowstate = 0;
	}
}


void normalizeAngles(D3DXVECTOR3& angles)
{
	while (angles.y > 180.f) {
		angles.y -= 360.f;
	}

	while (angles.y < -180.f){
		angles.y += 360.f;
	}
}

void clampAngles(D3DXVECTOR3& angles)
{
	if (angles.x > 89.0) {
		angles.x = 89.0;
	}
	if (angles.x < -89.0) {
		angles.x = -89.0;
	}
	if (angles.y > 180.0) {
		angles.y = 180.0;
	}
	if (angles.y < -180.0) {
		angles.y = -180.0;
	}
}

D3DXVECTOR3 getAnglesTo(DWORD playerToAim)
{
	auto base = playerToAim;
	if (Entity::getEntTeam(base) != LocalPlayer::getLocalTeam() && Entity::isValid(base))
	{
		D3DXVECTOR3 LocalPos = LocalPlayer::getAbsolutePos();
		D3DXVECTOR3 punchAngles = LocalPlayer::getLocalPunchAngles();
		D3DXVECTOR3 dPosition = LocalPos - Entity::getEntBonePos(base, 8);

		float dist = sqrt(pow(dPosition.x, 2) + pow(dPosition.y, 2));

		float angleXToPlayer = (atan(dPosition.x / dPosition.y)) * (180.0 / 3.14159265359);
		float angleYToPlayer = (atan2f(dPosition.z , dist)) * (180.0 / 3.14159265359);

		D3DXVECTOR3 newAngle((float)(angleYToPlayer), (float)(angleXToPlayer - 90.f), (0));

		if (dPosition.y >= 0) {
			newAngle.y += 180.f;
		}

		newAngle.y = newAngle.y*-1.f;

		normalizeAngles(newAngle);
		clampAngles(newAngle);

		return newAngle;

	}
}

DWORD getPlayerV2()
{
	double closest = 900;
	DWORD plrToAim = NULL;

	for (int i = 1; i < 32; i++)
	{
		auto base = Entity::getEntBase(i);

		D3DXVECTOR3 anglesTo = getAnglesTo(base);
		D3DXVECTOR3 currentAngles = LocalPlayer::getLocalViewAngles();
		D3DXVECTOR3 angleDifference;

		if (Entity::getEntTeam(base) != LocalPlayer::getLocalTeam() && Entity::isValid(base) && !Entity::getEntImmunity(base))
		{
			angleDifference.x = currentAngles.x - anglesTo.x;
			angleDifference.y = currentAngles.y - anglesTo.y;
			float dist = sqrt(pow(angleDifference.x, 2) + pow(angleDifference.y, 2));
			if (dist < closest)
			{
				closest = dist;
				plrToAim = base;
			}
		}
	}

	return(plrToAim);
}


void aimbotV2(DWORD playerToAimAt)
{
	auto target = playerToAimAt;
	D3DXVECTOR3 viewAngles = XOR(getAnglesTo(target));
	D3DXVECTOR3 currentAngles = XOR(LocalPlayer::getLocalViewAngles());

	if (Entity::getEntHp(target) > 0 && Entity::getEntTeam(target) != LocalPlayer::getLocalTeam() && Entity::isValid(target))
	{
		LocalPlayer::setLocalViewAngles(viewAngles);
	}
}

int SigOnState()
{
	return rpm<int>(LocalPlayer::getLocalPlayerEng() + 0x108);
}

bool Parser(char Parse[]){
	if (!strcmp(Parse, "true")) {
		return true;
	}
	else
		return false;
}


int main(int, char**)
{
	LPCSTR curdir = _T("./Config.ini");
    // Create application window
    WNDCLASSEX wc = { sizeof(WNDCLASSEX), CS_CLASSDC, WndProc, 0L, 0L, GetModuleHandle(NULL), NULL, NULL, NULL, NULL, _T("ImGui Example"), NULL };
    RegisterClassEx(&wc);
	XOR(HWND hwnd = CreateWindow(_T("ImGui Example"), _T("Avustaja 1.0"), WS_POPUP, 1000, 0, 1920, 600, NULL, NULL, wc.hInstance, NULL));
	//HWND hwnd = FindWindow(NULL, "Counter-Strike: Global Offensive");
	XOR(ShowWindow(::GetConsoleWindow(), SW_HIDE));

	SetLayeredWindowAttributes(hwnd, 0, 0, LWA_ALPHA);
	SetLayeredWindowAttributes(hwnd, 0, RGB(0, 0, 0), LWA_COLORKEY);

	MARGINS Margin = { -1, -1, -1, -1 };
	XOR(DwmExtendFrameIntoClientArea(hwnd, &Margin));

    // Initialize Direct3D
    if (CreateDeviceD3D(hwnd) < 0)
    {
        CleanupDeviceD3D();
        //UnregisterClass(_T("ImGui Example"), wc.hInstance);
        return 1;
    }


    // Show the window
    XOR(ShowWindow(hwnd, SW_SHOWDEFAULT));
    UpdateWindow(hwnd);
    // Setup Dear ImGui context
    IMGUI_CHECKVERSION();
    ImGui::CreateContext();
    ImGuiIO& io = ImGui::GetIO(); (void)io;
    //io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;  // Enable Keyboard Controls
	io.IniFilename = NULL;
	dankmemeforthewin();
    // Setup Dear ImGui style
    ImGui::StyleColorsDark();
    //ImGui::StyleColorsClassic();

    // Setup Platform/Renderer bindings
    ImGui_ImplWin32_Init(hwnd);
    ImGui_ImplDX11_Init(g_pd3dDevice, g_pd3dDeviceContext);

    // Load Fonts
    // - If no fonts are loaded, dear imgui will use the default font. You can also load multiple fonts and use ImGui::PushFont()/PopFont() to select them. 
    // - AddFontFromFileTTF() will return the ImFont* so you can store it if you need to select the font among multiple. 
    // - If the file cannot be loaded, the function will return NULL. Please handle those errors in your application (e.g. use an assertion, or display an error and quit).
    // - The fonts will be rasterized at a given size (w/ oversampling) and stored into a texture when calling ImFontAtlas::Build()/GetTexDataAsXXXX(), which ImGui_ImplXXXX_NewFrame below will call.
    // - Read 'misc/fonts/README.txt' for more instructions and details.
    // - Remember that in C/C++ if you want to include a backslash \ in a string literal you need to write a double backslash \\ !
    //io.Fonts->AddFontDefault();
    //io.Fonts->AddFontFromFileTTF("../../misc/fonts/Roboto-Medium.ttf", 16.0f);
    //io.Fonts->AddFontFromFileTTF("../../misc/fonts/Cousine-Regular.ttf", 15.0f);
    //io.Fonts->AddFontFromFileTTF("../../misc/fonts/DroidSans.ttf", 16.0f);
    //io.Fonts->AddFontFromFileTTF("../../misc/fonts/ProggyTiny.ttf", 10.0f);
    //ImFont* font = io.Fonts->AddFontFromFileTTF("c:\\Windows\\Fonts\\ArialUni.ttf", 18.0f, NULL, io.Fonts->GetGlyphRangesJapanese());
    //IM_ASSERT(font != NULL);

    // Our state
	
	GetPrivateProfileString("user", "Bunnyhop", "false", BunnyINI, 10, curdir);
	GetPrivateProfileString("user", "Autofire", "false", FireINI, 10, curdir);
	GetPrivateProfileString("user", "Wallhack", "false", WallINI, 10, curdir);
	GetPrivateProfileString("user", "Triggerbot", "false", TriggerINI, 10, curdir);
	GetPrivateProfileString("user", "Noflash", "false", FlashINI, 10, curdir);
	GetPrivateProfileString("user", "RadarHack", "false", RadarINI, 10, curdir);
	XOR(bool Bbunnyhop = Parser(BunnyINI));
	XOR(bool Bautofire = Parser(FireINI));
	XOR(bool Bwallhack = Parser(WallINI));
	XOR(bool Btriggerbot = Parser(TriggerINI));
	XOR(bool Bnoflash = Parser(FlashINI));
	XOR(bool Baimbot = false);
	XOR(bool Baimbot2 = false);
	bool Basdasdlol = false;
	XOR(bool Bradar = Parser(RadarINI));

	XOR(ImVec2 exitbutton = ImVec2(100, 30));
	XOR(ImVec2 refresh = ImVec2(150, 30));
	XOR(ImVec4 clear_color = ImVec4(0.0f, 0.0f, 0.0f, 0.0f));
	float Cham_color[4] = { 0, 0, 0, 0 };
	//float Cham_color[3] = { 255.0f, 255.0f, 255.0f};
	float clearColor[4] = { 0.0f,0.0f,0.0f,0.0f };
	XOR(HWND hcsgond = FindWindow(NULL, "Counter-Strike: Global Offensive"));

	if (attatchProc(XOR("csgo.exe"))) //XOR() is the xor encryption - more info about it in XOR.h
	{
		//Getting base address of client_panorama.dll so we can offset from it
		if (baseAddress = getModule(XOR("client_panorama.dll")))
		{
			if (engineAddress = getModule(XOR("engine.dll")))
			{
				//Set the global var for localplayer base address to reduce RPM calls
				LocalPlayer::setLocalPlayer();
				LocalPlayer::setLocalPlayerEng();
				// Main loop
				MSG msg;
				bool lol = false;
				ZeroMemory(&msg, sizeof(msg));
				dankmemeforthewin();
				HANDLE bhop = NULL;
				HANDLE Trigger = NULL;
				int lore = 0;
				const char* items[] = { "Left ALT", "Scroll Down", "Mouse2" };
				const char* current_item = items[0];
				
				while (msg.message != WM_QUIT || !GetAsyncKeyState(VK_F10))
				{
					
					if (SigOnState() == 6)
					{
						LocalPlayer::setLocalPlayer();
						LocalPlayer::setLocalPlayerEng();
					}
					dankmemeforthewin();
					dankmemeforthewin();
					dankmemeforthewin();
					// Poll and handle messages (inputs, window resize, etc.)
					// You can read the io.WantCaptureMouse, io.WantCaptureKeyboard flags to tell if dear imgui wants to use your inputs.
					// - When io.WantCaptureMouse is true, do not dispatch mouse input data to your main application.
					// - When io.WantCaptureKeyboard is true, do not dispatch keyboard input data to your main application.
					// Generally you may always pass all inputs to dear imgui, and hide them from your application based on those two flags.
					if (PeekMessage(&msg, NULL, 0U, 0U, PM_REMOVE))
					{
						TranslateMessage(&msg);
						DispatchMessage(&msg);
						continue;
					}
					if (GetAsyncKeyState(VK_INSERT) & 1)
					{
						lol = !lol;
						Sleep(100);
						XOR(ChangeClickability(lol, hwnd));

						if (lol == false)
						{
							XOR(SetForegroundWindow(hcsgond));
						}
					}

					if (Btriggerbot)
					{
						if (Trigger == NULL)
						{
							XOR(Trigger = CreateThread(NULL, NULL, &Koodi::Triggerbot, NULL, NULL, NULL));
						}
					}

					if (!Btriggerbot)
					{
						if (Trigger != NULL)
						{
							XOR(TerminateThread(Trigger, 0));
						}
					}
					


					if (Bautofire)
					{
						dankmemeforthewin();
						XOR(Koodi::autopistol());
					}

					if (Bradar)
					{
						for (int i = 0; i < 32; i++)
						{
							XOR(auto base = Entity::getEntBase(i));
							dankmemeforthewin();
							dankmemeforthewin();
							XOR(Entity::setSpotted(base, true));
						}
					}

					if (Bwallhack)
					{
						dankmemeforthewin();
						XOR(Koodi::ESP());
					}

					if (Bnoflash)
					{
						XOR(Koodi::noFlash());
					}

					if (Bbunnyhop)
					{
						if (bhop == NULL)
						{
							XOR(bhop = CreateThread(NULL, NULL, &Koodi::Bunnyhop, NULL, NULL, NULL));
						}
					}
					else
					{
						if (!Bbunnyhop)
						{
							XOR(TerminateThread(bhop, 0));
							XOR(bhop = NULL);
						}
					}

					if (Baimbot)
					{
						XOR(Koodi::aimbot(Koodi::getPlayer()));
					}

					// Start the Dear ImGui frame
					ImGui_ImplDX11_NewFrame();
					ImGui_ImplWin32_NewFrame();
					ImGui::NewFrame();

					// 1. Show the big demo window (Most of the sample code is in ImGui::ShowDemoWindow()! You can browse its code to learn more about Dear ImGui!).

					// 2. Show a simple window that we create ourselves. We use a Begin/End pair to created a named window.
					{
						static float f = 0.0f;
						static int counter = 0;

						ImGui::Begin("CS:GO eXternal 1.50");                          // Create a window called "Hello, world!" and append into it.
						ImGui::Text("Press Insert To hide and show  menu");

						ImGui::Checkbox("Bunnyhop         ", &Bbunnyhop);     // Edit bools storing our window open/close state
						ImGui::SameLine();
						ImGui::Checkbox("Autopistol", &Bautofire);
						ImGui::Checkbox("Radar Hack       ", &Bradar);
						ImGui::SameLine();
						ImGui::Checkbox("Wallhack", &Bwallhack);
						ImGui::Checkbox("Triggerbot", &Btriggerbot);
						//ImGui::Checkbox("asdasdlol", &Basdasdlol);
						if (Trigger)
						{
								ImGui::SameLine();
								if (ImGui::BeginCombo("Hotkey", current_item)) // The second parameter is the label previewed before opening the combo.
								{
									for (int n = 0; n < IM_ARRAYSIZE(items); n++)
									{
										bool is_selected = (current_item == items[n]); // You can store your selection however you want, outside or inside your objects
										if (ImGui::Selectable(items[n], is_selected))
										{
											current_item = items[n];
											XOR(LocalPlayer::setLocalTriggerKey(current_item));
											if (is_selected)
												ImGui::SetItemDefaultFocus();   // You may set the initial focus when opening the combo (scrolling + for keyboard navigation support)
										}
									}
									ImGui::EndCombo();
								}
						}

						ImGui::Checkbox("NoFlash", &Bnoflash);
						ImGui::Checkbox("Aimbot (Beta)", &Baimbot2);
						ImGui::Checkbox("Aimbot (DO NOT USE!)", &Baimbot);
						ImGui::NewLine();
						ImGui::NewLine();
						if (ImGui::Button("EXIT Cheat", exitbutton))
						{
							ImGui_ImplDX11_Shutdown();
							ImGui_ImplWin32_Shutdown();
							ImGui::DestroyContext();

							CleanupDeviceD3D();
							DestroyWindow(hwnd);
							CloseHandle(hProc);
							//UnregisterClass(_T("ImGui Example"), wc.hInstance);
							Sleep(100);
							return 0;
						}
						ImGui::SameLine();
						if (ImGui::Button("Refresh offsets", refresh))
						{
							LocalPlayer::setLocalPlayer();
							LocalPlayer::setLocalPlayerEng();
						}

						if (Baimbot2)
						{
							aimbotV2(getPlayerV2());
						}

						if (Bbunnyhop) {
							ImGui::Text("FLAGS: %i", LocalPlayer::getLocalFlags());
						}
						if(Bautofire)
						{
							float accpen = rpm<float>(LocalPlayer::LocalEngineaddress + netvars::m_fAccuracyPenalty);
							ImGui::Text("PEANLTY: %f", accpen);
							ImGui::Text("WEAPON: %i", Koodi::currentWeapon());
						}

						ImGui::Text("Application average %.3f ms/frame (%.1f FPS)", 1000.0f / ImGui::GetIO().Framerate, ImGui::GetIO().Framerate);
						ImGui::Text("LocalTeamID %i", LocalPlayer::getLocalTeam());
						ImGui::End();
					}

					if (Basdasdlol)
					{
						ImGui::Begin("Another Window", &Basdasdlol);   // Pass a pointer to our bool variable (the window will have a closing button that will clear the bool when clicked)
						ImGui::Text("Hello from another window!");
						ImGui::ColorEdit3("Enemy Color!", (float*)&Cham_color);
						//Koodi::Chams(Cham_color[0]/10000000, Cham_color[1]/10000000, Cham_color[2]/10000000);
						ImGui::End();
					}

					// Rendering
					ImGui::Render();
					g_pd3dDeviceContext->OMSetRenderTargets(1, &g_mainRenderTargetView, NULL);
					g_pd3dDeviceContext->ClearRenderTargetView(g_mainRenderTargetView, (float*)&clearColor);
					ImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData());

					g_pSwapChain->Present(1, 0); // Present with vsync
					//g_pSwapChain->Present(0, 0); // Present without vsync
					Sleep(1);
				}
			}
		}
	}
	else if (!attatchProc(XOR("csgo.exe")))
	{
		LPCTSTR Caption = "Game not found!";
		MessageBox(NULL,"Varmista että peli on käynnissä", Caption,
			MB_OK | MB_ICONWARNING);
	}

    ImGui_ImplDX11_Shutdown();
    ImGui_ImplWin32_Shutdown();
    ImGui::DestroyContext();

    CleanupDeviceD3D();
    DestroyWindow(hwnd);
    UnregisterClass(_T("ImGui Example"), wc.hInstance);
	CloseHandle(hProc);
    return 0;
}
